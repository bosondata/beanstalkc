NetworkSafeConnection
==================

It provides non-interrupted execution of calls to servers, when servers does down
or become unreachable over network. Call is simply blocked until server can be reached again.
This class remembers what tubes it was using or watching and restores it after reconnect.



Handling of network errors
--------------------------

    >>> import os, signal, threading, time
    >>> import beanstalkc

To get things going, we'll need to have a beanstalkd running:

    >>> def launch_beanstalkd():
    ...     pid = os.spawnlp(os.P_NOWAIT,
    ...                      'beanstalkd',
    ...                      'beanstalkd', '-l', '127.0.0.1', '-p', '14712')
    ...     time.sleep(0.2) # Give beanstalkd some time to start up.
    ...     return pid

    >>> def kill_beanstalkd(pid):
    ...     os.kill(pid, signal.SIGTERM)
    ...     time.sleep(0.2) # Also give beanstalkd some time to terminate.

    >>> pid = launch_beanstalkd()

Let's connect to this beanstalkd:

    >>> b = beanstalkc.NetworkSafeConnection(port=14712)

Let's use and watch some non-default tube:

    >>> b.use('test')
    'test'
    >>> b.using()
    'test'
    >>> b.watch('test')
    2
    >>> b.watching()
    ['default', 'test']

Put some data into 'test':

    >>> b.put('1')
    1
    >>> b.put('2')
    2


Now, if beanstalkd goes away, the NetworkSafeConnection will be not affected:

    >>> kill_beanstalkd(pid)

Instead, it will happily continue to work, once beanstalkd comes back up:

    >>> pid = launch_beanstalkd()

All data is gone because we haven't used persistent tubes (-b parameter for beanstalkd):

    >>> from pprint import pprint
    >>> pprint(b.stats())                           # doctest: +ELLIPSIS
    {...
     'current-connections': 1,
     'current-jobs-buried': 0,
     'current-jobs-delayed': 0,
     'current-jobs-ready': 0,
     'current-jobs-reserved': 0,
     'current-jobs-urgent': 0,
     ...}

But we should be still using and watching the same tubes as before:

    >>> b.using()
    'test'
    >>> b.watching()
    ['default', 'test']

Let's add something and remove it to prove that we have working client:

    >>> b.put('3')
    1
    >>> job = b.reserve()
    >>> job.body
    '3'
    >>> job.delete()

    >>> b.reserve(timeout=0) is None
    True

Clean beanstalkd:

    >>> kill_beanstalkd(pid)
